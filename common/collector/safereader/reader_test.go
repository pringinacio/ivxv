package safereader

import (
	"fmt"
	"io"
	"testing"
	"testing/iotest"
	"testing/quick"
)

type infinite struct{}

func (i *infinite) Read(p []byte) (n int, err error) {
	return len(p), nil
}

func TestRead(t *testing.T) {
	// testfn attempts to read bytes from an io.Reader of length wrapped in
	// a safereader with limit.
	testfn := func(t *testing.T, read, length, limit int64) {
		input := io.LimitReader(new(infinite), length)
		limited := New(input, limit)
		n, err := io.CopyN(io.Discard, limited, read)

		// The number of bytes read must be equal to the smallest value
		// of read, length and limit.
		expn := read
		if length < expn {
			expn = length
		}
		if limit < expn {
			expn = limit
		}
		if n != expn {
			t.Error("expected to read", expn, "bytes, but got", n)
		}

		switch {
		case read <= limit && read <= length:
			// If at most limit bytes were read and there was
			// enough data available, then err must be nil.
			if err != nil {
				t.Error("unexpected error:", err)
			}
		case read > length && length <= limit:
			// If more than length bytes were read, but less than
			// limit, then err must be io.EOF.
			if err != io.EOF {
				t.Error("unexpected error, want EOF:", err)
			}
		case read > limit && length > limit:
			// If more than limit bytes were both available and
			// read, then err must be a LimitExceededError.
			if err != limited.(*safereader).err {
				t.Error("unexpected error, want LimitExceededError:", err)
			}
		default:
			t.Error("unhandled test case")
		}
	}

	// First run some manual test cases.
	tests := []struct {
		read   int64 // Number of bytes to read.
		length int64 // Length of input stream.
		limit  int64 // Safereader limit.
	}{
		{0, 0, 0},    // Do nothing.
		{8, 16, 32},  // Read less than length and limit.
		{16, 16, 32}, // Read all, length less than limit.
		{16, 16, 16}, // Read all, length equal to limit.
		{32, 32, 16}, // Read all, length more than limit.
		{16, 32, 16}, // Read exactly limit, more data available.
		{32, 16, 16}, // Read more than length, length exactly limit.
	}

	for _, test := range tests {
		name := fmt.Sprintf("%d of %d with limit %d", test.read, test.length, test.limit)
		t.Run(name, func(t *testing.T) {
			testfn(t, test.read, test.length, test.limit)
		})
	}

	// Use testing/quick to run random black-box tests. Hopefully covers
	// any cases unhandled by the manual tests.
	t.Run("quick", func(t *testing.T) {
		// Use uint8 in testfn wrapper to keep values generated by
		// quick.Check small and non-negative.
		if err := quick.Check(func(read, length, limit uint8) bool {
			testfn(t, int64(read), int64(length), int64(limit))
			return !t.Failed()
		}, nil); err != nil {
			t.Error(err)
		}
	})
}

func TestReadError(t *testing.T) {
	// Ad-hoc solution for a reader which returns an error. The first read
	// will return a single byte and the second one ErrTimeout.
	r := iotest.TimeoutReader(iotest.OneByteReader(new(infinite)))

	// Create safereader with limit 1 and ensure that the underlying error
	// does not get replaced with a LimitExceededError.
	if _, err := io.Copy(io.Discard, New(r, 1)); err != iotest.ErrTimeout {
		t.Errorf("unexpected Read error: got %v, want %v", err, iotest.ErrTimeout)
	}
}
